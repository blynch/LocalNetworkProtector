"""Vulnerability management interacting with NVD and OSV.dev."""

from __future__ import annotations

import logging
import requests
from typing import Any, Dict, List, Optional
from dataclasses import dataclass, field

from .config import VulnerabilityScanningConfig

log = logging.getLogger(__name__)


@dataclass
class Vulnerability:
    id: str
    source: str  # 'NVD' or 'OSV'
    severity: str
    description: str
    references: List[str] = field(default_factory=list)


class VulnerabilityManager:
    """Checks for vulnerabilities using CPEs (NVD) and Package/Version (OSV)."""

    def __init__(self, config: VulnerabilityScanningConfig):
        self.config = config
        self._cache: Dict[str, List[Vulnerability]] = {}

    def check_service(self, product: str, version: str, cpe: str = "") -> List[Vulnerability]:
        """Check both NVD (via CPE) and OSV (via product/version)."""
        vulns = []
        
        # 1. Check NVD if CPE is present
        if cpe and self.config.nvd_api_key:
            vulns.extend(self._check_nvd(cpe))
        
        # 2. Check OSV if enabled
        if self.config.osv_enabled and product and version:
            vulns.extend(self._check_osv(product, version))
            
        return self._filter_severity(vulns)

    def _check_nvd(self, cpe: str) -> List[Vulnerability]:
        # Basic NVD implementation - in reality this needs robust logic and rate limiting handling
        # For this iteration, we'll keep it simple or return empty if no specific logic is requested.
        # But per requirements we need to implement it.
        
        # NOTE: NVD API 2.0 requires offset/limit pagination and is complex. 
        # Here we implement a simplified call.
        
        if not cpe:
            return []

        url = "https://services.nvd.nist.gov/rest/json/cves/2.0"
        headers = {"apiKey": self.config.nvd_api_key}
        params = {"cpeName": cpe}
        
        key = f"nvd:{cpe}"
        if key in self._cache:
            return self._cache[key]

        try:
            resp = requests.get(url, headers=headers, params=params, timeout=10)
            if resp.status_code == 200:
                data = resp.json()
                results = []
                for item in data.get("vulnerabilities", []):
                    cve = item.get("cve", {})
                    cve_id = cve.get("id")
                    
                    # Extract severity
                    metrics = cve.get("metrics", {})
                    # Try CVSS v3.1, then 3.0, then 2.0
                    cvss_data = None
                    if "cvssMetricV31" in metrics:
                        cvss_data = metrics["cvssMetricV31"][0].get("cvssData")
                    elif "cvssMetricV30" in metrics:
                        cvss_data = metrics["cvssMetricV30"][0].get("cvssData")
                    
                    severity = cvss_data.get("baseSeverity", "UNKNOWN").lower() if cvss_data else "unknown"
                    
                    desc = "No description"
                    if cve.get("descriptions"):
                        desc = cve["descriptions"][0].get("value", "")

                    results.append(Vulnerability(
                        id=cve_id,
                        source="NVD",
                        severity=severity,
                        description=desc
                    ))
                self._cache[key] = results
                return results
        except Exception as e:
            log.error("NVD API check failed: %s", e)
        
        return []

    def _check_osv(self, product: str, version: str) -> List[Vulnerability]:
        """Query OSV.dev for vulnerabilities."""
        # OSV query format
        payload = {
            "version": version,
            # We try to strict match 'PyPI' or generic ecosystem if known, 
            # but usually for a network map we might just guess or rely on product name.
            # OSV supports querying by package name. Product names from Nmap 
            # (e.g. 'nginx', 'openssh') often match package names in systems like Debian/Alpine.
            "package": {"name": product.lower()}  # Try generic name
        }
    
        key = f"osv:{product}:{version}"
        if key in self._cache:
            return self._cache[key]

        url = "https://api.osv.dev/v1/query"
        try:
            resp = requests.post(url, json=payload, timeout=10)
            if resp.status_code == 200:
                data = resp.json()
                results = []
                for vuln in data.get("vulns", []):
                    # Severity extraction from OSV is tricky, sometimes they have CVSS, sometimes standard specific severity
                    # We'll default to 'unknown' or try to parse
                    severity = "unknown"
                    if "severity" in vuln:
                        # OSV severity entries usually list [ { type: CVSS_V3, score: ... } ]
                        # We can roughly map score to string
                        pass # TODO implement parsing if needed, for now just report
                    
                    results.append(Vulnerability(
                        id=vuln.get("id"),
                        source="OSV (OSS-Fuzz/Other)",
                        severity=severity,
                        description=vuln.get("summary") or vuln.get("details", "")[:100]
                    ))
                self._cache[key] = results
                return results
        except Exception as e:
            log.error("OSV API check failed: %s", e)
        
        return []

    def _filter_severity(self, vulns: List[Vulnerability]) -> List[Vulnerability]:
        # Filter based on config.min_severity
        # Mapping: low->0, medium->1, high->2, critical->3
        severity_map = {"unknown": 0, "low": 0, "medium": 1, "high": 2, "critical": 3}
        min_val = severity_map.get(self.config.min_severity.lower(), 1)
        
        filtered = []
        for v in vulns:
            val = severity_map.get(v.severity.lower(), 0)
            if val >= min_val:
                filtered.append(v)
        return filtered
